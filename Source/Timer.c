#include "STC12C5A60S2.h"
#include <intrins.h>
#define uchar unsigned char
#define uint  unsigned int

//键盘引脚定义
sbit KEY_1 = P0^0;	 //A	  
sbit KEY_2 = P0^1;	 //B
sbit KEY_3 = P0^2;	 //C
sbit KEY_4 = P0^3;	 //D

//灯与扬声器定义
sbit	   Beep    	=	P1 ^ 0;	//扬声器
sbit	   LED		=	P1 ^ 4;	//液晶屏背光PWM控制
sbit	   ADC_L	=	P1 ^ 3;	//光敏二极管ADC采光定义
sbit	   DQ		=	P1 ^ 2;	//DS18B20温度传感器定义
sbit	   SID   	=	P1 ^ 1;	//LCD数据接口定义
sbit	   SCLK  	=	P3 ^ 2;	//LCD时钟接口定义
sbit	   IRQ      = 	P3 ^ 3;	//DS12C887时钟中断接口定义
sbit	   DSCS     = 	P3 ^ 7;	//DS12C887时钟片选接口定义
sbit	   DSAS     = 	P3 ^ 6;	//DS12C887时钟地址接口定义
sbit	   DSRW     = 	P3 ^ 5;	//DS12C887时钟写入接口定义
sbit	   DSDS     = 	P3 ^ 4;	//DS12C887时钟读出接口定义

//定义全局变量
unsigned char yy,mo,dd,xq,hh,mm,ss;//定义时间映射全局变量（专用寄存器）
unsigned char v,menu = 0;//定义静态小时更新用数据变量
bit BEEP_bit;//闹钟标志位
unsigned char e,r,sa,Temp;
/******************************************************************************
函数名：毫秒级CPU延时函数
调  用：DELAY_MS (?);
参  数：1~65535（参数不可为0）
返回值：无
结  果：占用CPU方式延时与参数数值相同的毫秒时间
备  注：应用于1T单片机时i<600，应用于12T单片机时i<125
/*****************************************************************************/
void DELAY_MS(unsigned int a){//延时函数 1MS/次	
		unsigned int i;
		while( --a != 0){		
			for(i = 0; i < 600; i++);  //一个 ; 表示空语句,CPU空转。
		}   				   //i 从0加到125，CPU大概就耗时1毫秒
}
/*****************************************************************************/
/******************************************************************************
函数名：蜂鸣器用延时函数
调  用：Delay (?);
参  数：1~65535（参数不可为0）
返回值：无
结  果：占用CPU方式延时与参数数值相同的微秒时间
备  注：蜂鸣器专用
/*****************************************************************************/
void Delay(int num){//蜂鸣器用延时函数
	while(num--) ;
}	
/*****************************************************************************/

/******************************************************************************
函数名：蜂鸣器驱动函数
调  用：
参  数：无
返回值：无
结  果：占用CPU方式延时与参数数值相同的微秒时间
备  注：蜂鸣器专用
/*****************************************************************************/
void Beep_start(void){//扬声器--开机音 
	unsigned char a;//定义变量用于发声的长度设置
	for(a=60;a>0;a--){//第一个声音的长度
		Beep = ~Beep;//取反扬声器驱动口，以产生音频
		Delay(600);//音调设置延时
	}
	for(a=100;a>0;a--){//同上
		Beep = ~Beep;
		Delay(480);//
	}
	for(a=100;a>0;a--){//同上
		Beep = ~Beep;
		Delay(180);//
	}
	Beep = 1;//音乐结束后扬声器拉高关闭
}
/*****************************************************************************/
void Beep_set(void){//扬声器--确定设置
	unsigned char a;//定义变量用于发声的长度设置
	for(a=50;a>0;a--){//第一个声音的长度
		Beep = ~Beep;//取反扬声器驱动口，以产生音频
		Delay(600);//音调设置延时
	}
	for(a=100;a>0;a--){//同上
		Beep = ~Beep;
		Delay(300);//
	}
	for(a=50;a>0;a--){//同上
		Beep = ~Beep;
		Delay(600);//
	}
	Beep = 1;//音乐结束后扬声器拉高关闭
}
/*****************************************************************************/
void Beep_bs(void){//扬声器--整点报时
	unsigned char a;//定义变量用于发声的长度设置
	for(a=150;a>0;a--){//第一个声音的长度
		Beep = ~Beep;//取反扬声器驱动口，以产生音频
		Delay(400);//音调设置延时
	}
	DELAY_MS(500);
	for(a=150;a>0;a--){//同上
		Beep = ~Beep;
		Delay(400);//
	}
	DELAY_MS(500);
	for(a=150;a>0;a--){//第一个声音的长度
		Beep = ~Beep;//取反扬声器驱动口，以产生音频
		Delay(400);//音调设置延时
	}
	DELAY_MS(500);
	for(a=250;a>0;a--){//同上
		Beep = ~Beep;
		Delay(200);//
	}
	Beep = 1;//音乐结束后扬声器拉高关闭
}
/*****************************************************************************/
void Beep_key(void){//扬声器--按键音
	unsigned char a;//定义变量用于发声的长度设置
	for(a=100;a>0;a--){//声音的长度
		Beep = ~Beep;
		Delay(300);//音调设置延时
	}
	Beep = 1;//音乐结束后扬声器拉高关闭
}		
/*****************************************************************************/
void Beep_al(void){//扬声器--闹钟 
	unsigned int a;//定义变量用于发声的长度设置
	for(a=2500;a>0;a--){//
		Beep = ~Beep;
		Delay(180);//
	}
	Beep = 1;//音乐结束后扬声器拉高关闭
}
/*****************************************************************************/

/******************************************************************************
函数名：LCD12864底层驱动程序（串行接口）
调  用：Write_byte();
参  数：要发送的字节数据
返回值：无
结  果：发送一个字节给LCD
备  注：
/*****************************************************************************/
void Write_byte(unsigned char byte) {
	unsigned char i;
 	for(i=0;i<8;i++){
   		SID=byte&0x80; //取出最高位
 		SCLK=1;
   		SCLK=0;
   		byte<<=1; //左移
   	}  
}
/******************************************************************************
函数名：写指令或数据函数
调  用：Write_test(?,?);
参  数：(位，字节）；位：0指令，1数据；
返回值：无
结  果：
备  注：
/*****************************************************************************/
void Write_test(bit start, unsigned char dat) {
	unsigned char start_data,Hdata,Ldata;
  	if(start==0){
		start_data=0xf8;	 //0：写指令
    }else{    
    	start_data=0xfa;  //1：写数据
	}
  	Hdata=dat&0xf0;		  //取高四位
  	Ldata=(dat<<4)&0xf0;  //取低四位
  	Write_byte(start_data);	  //发送起始信号
  	DELAY_MS(1); 
  	Write_byte(Hdata);	      //发送高四位
  	DELAY_MS(1);  
  	Write_byte(Ldata);		  //发送低四位
  	DELAY_MS(1);  
}
/*****************************************************************************/
//清屏函数
void Lcd_clr(void){
	Write_test(0,0x01);
	DELAY_MS(20);
}
/*****************************************************************************/
//向LCD发送一个字符串,长度64字符之内。
//应用：Write_string("您好！");
void Write_string(unsigned char *str){
		while(*str != '\0'){
			Write_test(1,*str++);
        }	*str = 0;
}
/****************************************************************************/

//初始化LCD函数
void Lcd_init(void)	 {
	DELAY_MS(200); //启动等待，等LCD讲入工作状态
  	Write_test(0,0x30);  //8 位界面，基本指令集
  	Write_test(0,0x0c);  //显示打开，光标关，反白关
  	Write_test(0,0x01);  //清屏，将DDRAM的地址计数器归零 
	DELAY_MS(200); //启动等待，等LCD讲入工作状态
}


/******************************************************************************
函数名：PWM初始化函数（控制背光亮度）
调  用：PWM_init();
参  数：无
返回值：无
结  果：将PCA初始化为PWM模式，初始占空比为0
备  注：需要更多路PWM输出直接插入CCAPnH和CCAPnL即可
/*****************************************************************************/
void PWM_init (void){
	CMOD=0x02; //设置PCA定时器
 	CL=0x00; 
 	CH=0x00;
	CCAPM1=0x42; //PWM1设置PCA工作方式为PWM方式（使用时删除//）
	CCAP1L=0x00; //设置PWM1初始值与CCAP0H相同
 	CCAP1H=0x00; // PWM1初始时为0
 	CR=1; //启动PCA定时器
}
/*****************************************************************************/

/******************************************************************************
函数名：PWM1占空比设置函数（控制背光亮度）
调  用：PWM1_set();
参  数：0x00~0xFF（亦可用0~255）
返回值：无
结  果：设置PWM模式占空比，为0时全部高电平，为1时全部低电平
备  注：如果需要PWM1的设置函数，只要把CCAP0L和CCAP0H中的0改为1即可
/*****************************************************************************/
void PWM1_set (unsigned char a){
	CCAP1L= a; //设置值直接写入CCAP0L
 	CCAP1H= a; //设置值直接写入CCAP0H
}
/*****************************************************************************/

/******************************************************************************
函数名：8位A/D转换初始化
调  用：Read_init (?);
参  数：输入的端口（0000 0XXX 其中XXX是设置输入端口号，可用十进制0~7表示，0表示P1.0，7表示P1.7）
返回值：无
结  果：
备  注：适用于STC12C5A60S2单片机
/*****************************************************************************/
void Read_init (unsigned char CHA){
	unsigned char AD_FIN=0; //存储A/D转换标志
    CHA &= 0x07;            //选择ADC的8个接口中的一个（0000 0111 清0高5位）
    ADC_CONTR = 0x40;		//ADC转换的速度（0XX0 0000 其中XX控制速度，请根据数据手册设置）
    _nop_();
    ADC_CONTR |= CHA;       //选择A/D当前通道
    _nop_();
    ADC_CONTR |= 0x80;      //启动A/D电源
    DELAY_MS(1);            //使输入电压达到稳定（1ms即可）
}

/******************************************************************************
函数名：8位A/D转换函数（采集光敏电阻数据）
调  用：? = Read ();
参  数：无
返回值：8位的ADC数据
结  果：读出指定ADC接口的A/D转换值，并返回数值
备  注：适用于STC12C5A60S2单片机
/*****************************************************************************/
unsigned char Read (void){
	unsigned char AD_FIN=0; //存储A/D转换标志
    ADC_CONTR |= 0x08;      //启动A/D转换（0000 1000 令ADCS = 1）
    _nop_();
    _nop_();
    _nop_();
    _nop_();
    while (AD_FIN ==0){     //等待A/D转换结束
        AD_FIN = (ADC_CONTR & 0x10); //0001 0000测试A/D转换结束否
    }
    ADC_CONTR &= 0xE7;      //1111 0111 清ADC_FLAG位, 关闭A/D转换, 
return (ADC_RES);          //返回A/D转换结果（8位）
}
/*****************************************************************************/

/*****************************************************************************/
//DS12C887写数据函数
void write_clock(unsigned char add,unsigned char dat)
{
	DSCS=0;
	DSAS=1;
	DSDS=1;
	DSRW=1;
	P2=add;
	DSAS=0;
	DSRW=0;
	P2=dat;
	DSRW=1;
	DSAS=1;
	DSCS=1;				
}
/*****************************************************************************/

/*****************************************************************************/
//DS12C887读数据函数
unsigned char read_clock(unsigned char add)
{
 	unsigned char ds_date;
	DSAS=1;
	DSDS=1;
	DSRW=1;
	DSCS=0;
	P2=add;
	DSAS=0;
	DSDS=0;
	P2=0xff;
	ds_date=P2;
	DSDS=1;
	DSAS=1;
	DSCS=1;
	return ds_date;	
}
/*****************************************************************************/
//DS18B20初始化函数
void Init_DS18B20(void)
{
	uchar x=0;
	DQ = 1;            //DQ复位
	Delay(80);    //稍做延时
	DQ = 0;            //单片机将DQ拉低
	Delay(800);   //精确延时大于480us
	DQ = 1;            //拉高总线
	Delay(140);
	x=DQ;   
	Delay(200);
}

//DS18B20读出函数
uchar Read_18B20(void)
{
	uchar i=0;
	uchar dat = 0;

	for (i=8;i>0;i--)
	{
	    DQ = 0;//给脉冲信号
	    dat>>=1;
	    DQ = 1;//给脉冲信号
	    if(DQ)
	    dat|=0x80;
	    Delay(40);
	}
	return(dat);
}

//DS18B20写入函数
void Write_18B20(uchar dat)
{
   uchar i=0;

   for (i=8; i>0; i--)
   {
   		DQ = 0;
    	DQ = dat&0x01;
    	Delay(50);
    	DQ = 1;
    	dat>>=1;
   }
}

//获取温度函数
void Get_Temperature(void)
{
	uchar TH,TL;		
	Init_DS18B20();
	Write_18B20(0xCC);    	
	Write_18B20 (0x44); 	
	Delay(1000);     	
	Init_DS18B20();
	Write_18B20 (0xCC); 
	Write_18B20 (0xBE); 	
	Delay(1000);
	TL=Read_18B20();    //先读的是温度值低位
	TH=Read_18B20();    //接着读的是温度值高位
	Temp=TH*16+TL/16;     //实际温度值=(TH*256+TL)/16,即TH*16+TL/16
}


/*****************************************************************************/
//常用时钟数据读取函数
void read_time(void){
	ss = read_clock(0x00);//读取秒数据
	mm = read_clock(0x02);//读取分钟数据
	hh = read_clock(0x04);//小时
	dd = read_clock(0x07);//日
	mo = read_clock(0x08);//月
	yy = read_clock(0x09);//年
	xq = read_clock(0x06);//星期
}
/*****************************************************************************/

/*****************************************************************************/
//根据选择调整的相应项目加1并写入DS12C887调时用加1程序
void Set_time(unsigned char sel){ 
  unsigned char address,item;
  unsigned char max,mini;
  Write_test(0,0x92);
  Write_string("调整");
 
  if(sel==5)  {Write_string("分钟");address=0x02; max=59;mini=0;}    //分钟
  if(sel==4)  {Write_string("小时");address=0x04; max=23;mini=0;}    //小时
  if(sel==3)  {Write_string("星期");address=0x06; max=7;mini=1;}    //星期  
  if(sel==2)  {Write_string("日期");address=0x07; max=31;mini=1;}    //日
  if(sel==1)  {Write_string("月份");address=0x08; max=12;mini=1;}    //月
  if(sel==0)  {Write_string("年份");address=0x09; max=99; mini=0;}    //年
 
  if(sel==30)  {Write_string("报时");address=0x0E; max=1;mini=0;}    //
  if(sel==40)  {Write_string("背光");address=0x0F; max=9;mini=0;}    //
  
  //读取12C887某地址上的数值赋给item 
  item=read_clock(address);
  if(KEY_2 == 0){	 
  	item++;//数值加1
  }
  if(KEY_1 == 0){ 
  	item--;//数值减1
  }  
  if(item>max) item=mini;//查看数值有效范围   
  if(item<mini) item=max;           
  
  write_clock(address,item);//写入12C887

  if(sel==5){//当设置分钟时，秒值自动清0
		write_clock(0x00,0x00);//秒
  }
   
}
/**********************************************************************************************/
/*********************************************************************************************
函数名：实时时钟数据刷新
调  用：updata(); 
参  数：无
返回值：无
结  果：刷新正常界面显示的时钟数据
备  注：
/**********************************************************************************************/
void updata (void){//实时时钟刷新数据
	unsigned char m;
	read_time();
	Write_test(0,0x88);
	Write_string("20");
	Write_test(1,yy/10+0x30);//
	Write_test(1,yy%10+0x30);
	Write_string("-");
	Write_test(1,mo/10+0x30);
	Write_test(1,mo%10+0x30);
	Write_string("-");
	Write_test(1,dd/10+0x30);
	Write_test(1,dd%10+0x30);
	Write_string(" ");
	Write_test(1,hh/10+0x30);
	Write_test(1,hh%10+0x30);
	m = read_clock(0x00)&0x01;//冒号":"以秒闪烁
	if(m == 1){//秒点闪烁
		Write_string(":");
	}else{
		Write_string(" ");
	}				
	Write_test(1,mm/10+0x30);
	Write_test(1,mm%10+0x30);
//
	Write_test(0,0x98);
	Write_string("星期");
	if(xq==7)  {Write_string("日");}    //
  	if(xq==6)  {Write_string("六");}    //
  	if(xq==5)  {Write_string("五");}    //
  	if(xq==4)  {Write_string("四");}    //
  	if(xq==3)  {Write_test(1,0xc8);Write_test(1,0xfd);} //此指令等于Write_string("三"); 因为“三”的内码失效。
  	if(xq==2)  {Write_string("二");}    //
  	if(xq==1)  {Write_string("一");}    //星期一
//

	Write_test(0,0x9C);		//温度在LCD上的写入位置		
	Write_string("温度");	//度C
	Get_Temperature();
	Write_test(1,Temp%100/10+0x30);	//显示温度十位
	Write_test(1,Temp%10+0x30);	//个位
	Write_string("℃");	//度C
	
}
/*********************************************************************************************
函数名：渐亮和渐暗切换显示处理
调  用：CH_H(); CH_L(); 
参  数：无
返回值：无
结  果：背光渐亮和变暗
备  注：用于显示界面切换的效果
/**********************************************************************************************/
void CH_H (void){
	unsigned char e;
	DELAY_MS(500); //显示等留0.5秒
	for(e=0;e<(read_clock(0x0F)*0x1C);e=e+2){
		PWM1_set(e);
		DELAY_MS (5);
	}
}
/*****************************************************************************/
void CH_L (void){
	unsigned char e;
	for(e=(read_clock(0x0F)*0x1C);e>0;e=e-2){
		PWM1_set(e);
		DELAY_MS (5);
	}
	PWM1_set(0);
	Lcd_clr();//清屏

}
/**********************************************************************************************/
/*********************************************************************************************
函数名：自动背光检测程序
调  用：AUTO_B();
参  数：无
返回值：无
结  果：检测环境光并控制背光亮度
备  注：
/**********************************************************************************************/
void AUTO_B (void){ //
	unsigned char d;
	d = Read();
	if(read_clock(0x10) == 1){//检查自动调光开关
		if(d > 0xD0){//
			PWM1_set(1);//
		}else{
			PWM1_set(read_clock(0x0F)*0x1C);//
		}
	}
}
/**********************************************************************************************/
/*********************************************************************************************
函数名：整点报时检查处理
调  用：search_bs(); 
参  数：无
返回值：无
结  果：检测整点并报时
备  注：
/**********************************************************************************************/
void search_bs(void){//检查整点报时
	unsigned char i;
	if(read_clock(0x00)==0 && read_clock(0x02)==0){	
		i = read_clock(0x85);
		if(i==1){
			Beep_bs();
		}
		updata();//刷新显示
	}
}
/*********************************************************************************************/
/*********************************************************************************************
函数名：主函数
调  用：无
参  数：无
返回值：无
结  果：程序开始处，无限循环
备  注：
/**********************************************************************************************/
void main (void){
	BEEP_bit = 0;//闹钟标志位清0   

	Read_init (3);
	PWM_init();	
	//Init_12C887();
	Lcd_init();//初始化液晶显示器
	EA=1;
	EX1=1;
	IT1=1;
	Beep_start();
	Lcd_clr();//清屏 
	menu = 0;//菜单标志位清0
	Write_string("    毕业设计    信电学院自动091 多功能型电子时钟    作者：黎晓");//
	//----------|-------1-------|-------3-------|-------2-------|-------4-------|-----//标尺
	CH_H();//渐亮
	DELAY_MS(2000); //显示等留2秒
	CH_L();//渐暗
	Write_string("    电子时钟    ---------- --:--                        温度--℃");//
	//----------|-------1-------|-------3-------|-------2-------|-------4-------|-----//标尺
	updata ();
	CH_H();//渐亮
	DELAY_MS (500);	
	
/**********************************************************************************************/
	while(1){//主循环
		if(read_clock(0x11) == 1 && BEEP_bit == 1){
			Beep_al();
			if(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0){
				BEEP_bit = 0;
				Beep = 1;
			}
		}
		if (menu == 0){   //正常走时菜单
			search_bs();//检测整点报时
			if(read_clock(0x00) != sa){//显示更新处理，防止重复更新,每秒更新一次
				sa = read_clock(0x00);
				updata ();//更新主界面时间数据
				AUTO_B();//自动背光控制检查
			}
			if(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0){
				DELAY_MS (80);	   //按键去抖
				if(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0){
					Beep_key();//按键声音
					CH_L();//LED渐暗
					Write_string("A:时钟  B:闹钟 A       [ ]     C    功能菜单   BC:报时  D:背光 D");//
					//----------|-------1-------|-------3-------|-------2-------|-------4-------|-----//标尺
					CH_H();//LED渐亮
					menu = 1;e = 9;
					while(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0);
				}
			}
		}
/**********************************************************************************************/
		if (menu == 1){   //设置菜单（自动回归）
			if(read_clock(0x00) != ss){
				ss = read_clock(0x00);
				Write_test(0,0x8C);		//
				Write_test(1,e+0x30);	//倒计时
				e--;	
				if(e==0){
					menu = 0;
					Beep_key();//按键声音
					CH_L();//LED渐暗
					updata ();//更新主界面时间数据
					Write_string("    电子时钟    ---------- --:--                        温度--℃");//
					CH_H();//LED渐亮
				}
			}
			if(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0){
				DELAY_MS (80);	   //按键去抖
				if(KEY_1 == 0){ //A：时间
					menu = 10;
					Beep_set();//确定按键音
					CH_L();//LED渐暗
					Write_string("[-1 +1 NEXT ESC]                                                ");//
					//----------|-------1-------|-------3-------|-------2-------|-------4-------|-----//标尺
					updata ();//更新主界面时间数据
					CH_H();//LED渐亮
					e = 0;
					Set_time(e);//调整
				}
				if(KEY_2 == 0){ //B：闹钟
					Beep_set();//确定按键音
					CH_L();//LED渐暗
					Write_string("[-1 +1  SET ESC]闹钟总开关                                      ");//
					//----------|-------1-------|-------3-------|-------2-------|-------4-------|-----//标尺
					DELAY_MS (20);
					Write_test(0,0x8E);//写入指定区域
					if(read_clock(0x11) == 1){
						Write_string("开");
					}else{
						Write_string("关");
					}
					CH_H();//LED渐亮
					menu = 20;
				}
				if(KEY_3 == 0){
					Beep_set();//确定按键音
					CH_L();//LED渐暗
					Write_string("[-1 +1      ESC]                                                ");//
					//----------|-------1-------|-------3-------|-------2-------|-------4-------|-----//标尺
					Set_time(30);//调整
					CH_H();//LED渐亮
					menu = 30;
				}
				if(KEY_4 == 0){
					Beep_set();//确定按键音
					CH_L();//LED渐暗
					Write_string("[-1 +1 AUTO ESC]                                                ");//
					//----------|-------1-------|-------3-------|-------2-------|-------4-------|-----//标尺
					Set_time(40);//调整
					CH_H();//LED渐亮
					menu = 40;
				}
			}
			while(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0);
		}
/**********************************************************************************************/
		if (menu == 10){   //实时时钟设置
			updata ();//更新主界面时间数据
			if(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0){
       			DELAY_MS (80);	   //去抖
				if(KEY_3 == 0){  //当是调时状态 本键用于调整下一项
					e++;
					if (e >= 6 ){
						e = 0;
					}
					Set_time(e);//调整				
					Beep_key();//按键音
      			}
       			if(KEY_4 == 0){				
					Beep_set();//确定按键音
					menu = 0;	  //退出调时
					e = 0;		//“下一项”计数器清0								
					while(KEY_1 == 0);//等待键松开 			
					CH_L();//LED渐暗
					updata ();	//刷新数据
					Write_string("    电子时钟    ---------- --:--                        温度--℃");//
					CH_H();//LED渐亮
				} 
	       		if(KEY_1 == 0){				
					Set_time(e);//调整
					Beep_key();//按键音
				}
	       		if(KEY_2 == 0){				
					Set_time(e);//调整
					Beep_key();//按键音
				}
			while(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0);
			}
		}
/**********************************************************************************************/
		if (menu == 20){   //闹钟设置
			if(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0){
       			DELAY_MS (80);	   //去抖
				if(KEY_4 == 0){  //当是调时状态 本键用于调整下一项
					Beep_set();//确定按键音
					menu = 0;	  //退出调时
					while(KEY_1 == 0);//等待键松开 			
					CH_L();//LED渐暗
					updata ();	//刷新数据
					Write_string("    电子时钟    ---------- --:--                        温度--℃");//
					CH_H();//LED渐亮
				}
				if(KEY_3 == 0){  //当是调时状态 本键用于调整下一项
						
					if(read_clock(0xc7) == 1){					
		 				write_clock(0xc6,0);			
					}else{					
		 				write_clock(0xc6,1);			
					}		
		 			
					Write_test(0,0x8E);//写入指定区域
					if(read_clock(0x11) == 1){
						Write_string("开");
					}else{
						Write_string("关");
					}
					Beep_set();//调时提示音		
				}
				if(KEY_2 == 0){  //
					Set_time(e);//调整
					Beep_key();//按键音
				}
				if(KEY_1 == 0){  //
					Set_time(e);//调整
					Beep_key();//按键音
				}
			while(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0);
			}
		}

/**********************************************************************************************/
		if (menu == 30){   //整点报时设置
			Write_test(0,0x98);//
			if(read_clock(0x0E)==1){
				Write_string("    整点报时开  ");
			} else{
				Write_string("    整点报时关  ");	
			}
			if(KEY_1 == 0 || KEY_2 == 0 ||KEY_4 == 0){
       			DELAY_MS (80);	   //去抖
				if(KEY_4 == 0){  //当是调时状态 本键用于调整下一项
					Beep_set();//确定按键音
					menu = 0;	  //退出调时
					while(KEY_1 == 0);//等待键松开 			
					CH_L();//LED渐暗
					updata ();	//刷新数据
					Write_string("    电子时钟    ---------- --:--                        温度--℃");//
					CH_H();//LED渐亮
				}
				if(KEY_1 == 0){  //
					Set_time(menu);//调整
					Beep_key();//确定按键音
				}
				if(KEY_2 == 0){  //
					Set_time(menu);//调整
					Beep_key();//确定按键音
				}
			while(KEY_1 == 0 || KEY_2 == 0 ||KEY_4 == 0);
			}
		}
/**********************************************************************************************/
		if (menu == 40){   //背光设置
			Write_test(0,0x88);//	
			Write_string("自动背光控制    ");//
			//----------|-------1-------|-----//标尺
			
			if(read_clock(0x10) == 1){//自动背光开关状态
				Write_string("开");
			}else{
				Write_string("关");
			}
			Write_test(0,0x98);//	
			Write_string("  背光亮度  ");//
			//----------|-------1-------|-----//标尺
			Write_test(0,0x9E);
			Write_test(1,read_clock(0x0F)+0x30);
			Write_string("/9 ");//
			//----------|-------1-------|-----//标尺
			if(KEY_1 == 0 || KEY_2 == 0 || KEY_3 == 0 ||KEY_4 == 0){
       			DELAY_MS (80);	   //去抖
				if(KEY_4 == 0){  //当是调时状态 本键用于调整下一项
					Beep_set();//确定按键音
					menu = 0;	  //退出调时
					while(KEY_1 == 0);//等待键松开 			
					CH_L();//LED渐暗
					updata ();	//刷新数据
					Write_string("    电子时钟    ---------- --:--                        温度--℃");//
					CH_H();//LED渐亮
				}				   
				if(KEY_3 == 0){  //设计自动亮度控制			
					if(read_clock(0x10) == 1){					
		 				write_clock(0x10,0);			
					}else{					
		 				write_clock(0x10,1);			
					}		
					Beep_set();//确定按键音
				}
				if(KEY_2 == 0){  //
					Set_time(menu);//调整
					Beep_key();//确定按键音
				}
				if(KEY_1 == 0){  //
					Set_time(menu);//调整
					Beep_key();//确定按键音
				}
			while(KEY_1 == 0 || KEY_2 == 0 ||KEY_3 == 0 ||KEY_4 == 0);
			}
		PWM1_set(read_clock(0x0F)*0x1C);//
		}
	}//while	
}//main
/*****************************************************************************/
/*****************************************************************************
//中断服务函数：
******************************************************************************/
void exter() interrupt 2
{	uchar c;
	BEEP_bit=1;
	c=read_clock(0x0c);
}